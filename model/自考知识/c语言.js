module.exports = [
	
	{
		title:"函数",
		body:[
			'形参不占用内存',
			'函数返回值以函数声明时指定的类型为准，数值类型自动转化为指定类型',
			"类函数返回数据成员地址，则可以通过*A.getX()=100操作",
			"c++常用流控制符号：dec十进制，hex16进制，otc8进制",
			"unsigned和signed只修饰int和char类型"
		]
	},
	{
		title:"内联函数",
		body:[
			'只有那些规模较小而又被频繁调用的简单函数,才适合于声明为inline 函数｡',
			"可以在声明函数和定义函数时同时写 inline,也可以只在其中一处声明 inline,效果相同,都能按内臵函数处理｡",
			"内联函数中不能包括复杂的控制语句,如循环语句和 switch 语句｡"
		]
	},	
	{
		title:"函数指针",
		body:[
			"函数指针声明：int (*fn1)(int);",
			"函数指针定义：fn1 = &handler;",
			"函数指针使用：(*fn1)(100)",
			"类成员函数指针声明：int (Person::*handler)(int);",
			"类成员函数指针定义：handler=&Person::func",
			"类成员函数指针定义：Person p; (p.*handler)(100)",
		]
	},
		
	{
		title:"类常函数和常数据",
		body:[
			"常对象定义： Person const t1(12,34,46)",
			"常对象注意事项： 如果一个对象被声明为常对象，则不能调用该对象的非const型的成员函数(除了由系统自动调用的隐式的构造函数和析构函数)",
			"类常函数声明：void test() const;",
			"类常函数能被常对象调用，但只能访问常对象数据，不可修改常对象数据",
			"常成员函数可以引用const数据成员，也可以引用非const的数据成员。const数据成员可以被const成员函数引用，也可以被非const的成员函数引用",
			"常成员函数不能调用另一个非const成员函数。"
		]
	},	
	
	{
		title:"类其他",
		body:[
			"类数组：Person person[2] = {Person(int,int),Person(int,int)}",
			"类拷贝构造函数声明： Person(Person const &p)",
			"指向常变量的指针变量可以指向const和非const型的变量，而指向非const，型变量的指针变量只能指向非const的变量。",
			"动态创建对象：Person *p; p = new Person(int,int);",
			"在执行new运算时，如果内存量不足，无法开辟所需的内存空间，返回一个0指针值",
			"类的数据成员中不能包括动态分配的数据",
			"类static成员函数不能使用this指针",
			"类static成员函数不能访问类非静态成员"
		]
	},	
	{
		title:"模板类",
		body:[
			"类模板声明：template <class 类型参数名> class Person ",
			"类模板和函数模板不具有参数类型转化功能",
			"函数模板声明： template <class 类型参数名> void function",
			"类模板使用： 类模板名<实际类型名> 对象名(实参表列);",
			"类模板外定义成员函数：template <class 虚拟类型参数>函数类型 类模板名<虚拟类型参数>::成员函数名(函数形参表列) {…}"
		]
	},
	{
		title:"运算符重载",
		body:[
			"运算符重载声明：函数类型 operator 运算符名称 (形参表列)",
			"不能进行重载的运算符5中：[.|.*|::|?:|sizeof]",
			"重载运算符函数不能有默认参数",
			"重载运算符形参必须有一个是同类对象，不能全部是c++全部类型",
			"类的重载函数，可以是类的成员函数，也可以是友元函数和普通函数",
			"“++”和“--”运算符有两种使用方式,前置自增运算符和后置自增运算符,在重载函数中增加一个int型参数表示后置",
			"类型转换构造函数声明：operator double()",
			"类型转换构造函数，在函数名前面不能指定函数类型,函数没有参数｡ 其返回值的类型是由函数名中指定的类型名来确定的｡ 类型转换函数只能作为成员函数,因为转换的主体是本类的对象｡ 不能作为友元函数或普通函数｡",
		]
	},
	{
		title:"类静态方法和静态成员",
		body:[
			"静态方法是类成员，不是对象成员",
			"静态方法不能直接访问类非静态成员数据",
			"静态方法没有this指针",
			"静态方法不是虚函数",
			"静态成员可以被对象方法直接访问"
		]
	},
	{
		title:"友元函数",
		body:[
			"关键字friend",
			"类可以作为友元，声明：friend class 类A，此时类A的所有成员函数可以访问该类的所有成员",
			"友元不具有传递性和交换性",
			"友元不是类本身的成员",
			"友元可以在类的任何位置声明"
		]
	},
	{
		title:"常对象和常函数",
		body:[
			"常量成员包括常量数据成员，静态常数成员，常引用",
			"常指针声明时必须初始化",
			"常函数声明：void fn() const",
			"常成员函数只能调用常成员函数，而不能调用非常函数",
			"常函数和非常函数可以重载，void fn() 与 void fn() const;常对象调用常函数，非常对象调用非常函数",
			"常函数的const实际修饰的是this指针",
			"常对象：A const a; 即实例化对象时，用const修饰",
			"常对象和常对象成员只能调用常函数",
			"普通对象可以调用常函数和非常函数",
			"常数据成员，必须通过初始化列表初始化，即：A(int a,int b):x(a),y(b){}",
			"A(int a,int b){x=a,y=b} 这种初始化报错",
		]
	},
	{
		title:"类的继承",
		body:[
			"派生类继承了基类的所有数据成员和成员函数",
			"class 派生类名：［继承方式］ 基类名{派生类新增加的成员};",
			"继承方式：public,private,protected, 继承方式是可选的，默认为private",
			"构造函数和析构函数是不能从基类继承的",
			"public继承，派生类保持基类原有的访问属性",
			"private私有继承，基类公用成员和保护成员在派生类中改为私有属性",
			"protected保护继承，基类公用成员和保护成员在派生类中改为保护成员",
			"通过基类的公用成员函数来引用基类的私有数据成员。"
		]
	},
	{
		title:"类的多重继承",
		body:[
			"派生类构造函数名（总参数表列）：基类构造函数名（参数表列）{派生类中新增数据成员初始化语句}",
			"",
			'派生类和基类都定义了数据成员x，基类有setX成员函数，派生类没有，当派生类调用setX函数时，值将赋值到基类的x上，而派生类的x不会被赋值，调用基类未重写的函数时，this将指向基类',
			"",
			"基类的static数据成员，为基类和派生类对象共享;使用static数据成员，必须实例化对象前，赋初值: int Person::num = 10;",
			"",
			"构造函数不能是虚函数。析构函数能够是虚函数",
			"析构函数能够是纯虚的，但纯虚析构函数必须有定义体，由于析构函数的调用是在子类中隐含的。",
		]
	},
	{
		title:"类",
		body:[
			"派生类访问基类被覆盖成员方法：this->Parent::fn();",
			"在构造对象时，先调用基类构造函数，再执行派生类构造函数",
			"析构对象时，先执行派生类析构函数，再执行基类析构函数",
			"",
			"派生类构造函数的任务：",
			"1，基类数据成员的初始化",
			"2，子对象数据成员的初始化",
			"3，派生类数据成员的初始化",
			
			"基类声明了带参数的构造函数，则派生类必须显示的调用基类的构造函数，并传入相应的初始化参数",
			"基类的同名成员在派生类中屏蔽，需要通过this->Parent::name显示调用",
			"虚基类构造函数，不仅要初始化基类构造函数，也需要初始化虚基类；",
			"可以用子类(即公用派生类)对象对其基类对象赋值。",
			"",
			"多态性分为两类:静态多态性和动态多态性",
			"静态多态性是通过函数的重载实现的",
			"动态多态性是通过虚函数(virtual function)实现的。",
			"",
			"",
		]
	},
	
	{
		title: "iomanip头文件流控制符",
		body:[
			"setbase(8,10,16): 设置整型输出的进制，cout<<setbase(8) << a << endl;",
			"showbase: 显示进制前缀，10进制空，8进制o,16进制ox，cout<<showbase<< endl;",
			"setw(10): 设置字段宽度，不足以空格代替，超出则省略；如double b=10.2983; 如设置setw(3) 则输出10.29;",
			"oct10进制，hex16进制，dec10进制",
			"setprecision(n): 设置浮点数的有效个数",
			"setiosflags(): "
		]
	},
	{
		title:"类数据成员指针和成员函数指针",
		body:[
			"数据成员指针声明：<类型说明符> <类名>::* <指针变量名>",
			"成员函数指针声明：<类型说明符> (<类名>::*<指针变量名>) (参数列表)"
		]
	},	
	
		
]


/*


















多态性定义：:向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为(即方法)。




{
  title:"",
  body:[
  ]
},
*/
