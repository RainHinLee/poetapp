module.exports = [
	{
		title:"函数",
		body:[
			'形参不占用内存',
			'函数返回值以函数声明时指定的类型为准，数值类型自动转化为指定类型',
		]
	},
	{
		title:"内联函数",
		body:[
			'只有那些规模较小而又被频繁调用的简单函数,才适合于声明为inline 函数｡',
			"可以在声明函数和定义函数时同时写 inline,也可以只在其中一处声明 inline,效果相同,都能按内臵函数处理｡",
			"内联函数中不能包括复杂的控制语句,如循环语句和 switch 语句｡"
		]
	},	
	{
		title:"函数指针",
		body:[
			"函数指针声明：int (*fn1)(int);",
			"函数指针定义：fn1 = &handler;",
			"函数指针使用：(*fn1)(100)",
			"类成员函数指针声明：int (Person::*handler)(int);",
			"类成员函数指针定义：handler=&Person::func",
			"类成员函数指针定义：Person p; (p.*handler)(100)",
		]
	},
		
{
  title:"类常函数和常数据",
  body:[
		"常对象定义： Person const t1(12,34,46)",
		"常对象注意事项： 如果一个对象被声明为常对象，则不能调用该对象的非const型的成员函数(除了由系统自动调用的隐式的构造函数和析构函数)",
		"类常函数声明：void test() const;",
		"类常函数能被常对象调用，但只能访问常对象数据，不可修改常对象数据",
		"常成员函数可以引用const数据成员，也可以引用非const的数据成员。const数据成员可以被const成员函数引用，也可以被非const的成员函数引用",
		"常成员函数不能调用另一个非const成员函数。"
  ]
},	
	
{
  title:"类其他",
  body:[
		"类数组：Person person[2] = {Person(int,int),Person(int,int)}",
		"类拷贝构造函数声明： Person(Person const &p)",
		"指向常变量的指针变量可以指向const和非const型的变量，而指向非const，型变量的指针变量只能指向非const的变量。",
		"动态创建对象：Person *p; p = new Person(int,int);",
		"在执行new运算时，如果内存量不足，无法开辟所需的内存空间，返回一个0指针值",
		"类的数据成员中不能包括动态分配的数据",
		"类static成员函数不能使用this指针",
		"类static成员函数不能访问类非静态成员"
  ]
},	
{
  title:"友元函数",
  body:[
		"友元函数使用friend修饰",
		"友元函数可以访问类的私有成员",
		"类模板声明：template <class 类型参数名> class Person ",
		"函数模板声明： template <class 类型参数名> void function",
		"类模板使用： 类模板名<实际类型名> 对象名(实参表列);",
		"类模板外定义成员函数：template <class 虚拟类型参数>函数类型 类模板名<虚拟类型参数>::成员函数名(函数形参表列) {…}"
  ]
},
{
  title:"运算符重载",
  body:[
		"运算符重载声明：函数类型 operator 运算符名称 (形参表列)",
		"不能进行重载的运算符5中：[.|.*|::|?:|sizeof]",
		"重载运算符函数不能有默认参数",
		"重载运算符形参必须有一个是同类对象，不能全部是c++全部类型",
		"类的重载函数，可以是类的成员函数，也可以是友元函数和普通函数",
		"“++”和“--”运算符有两种使用方式,前置自增运算符和后置自增运算符,在重载函数中增加一个int型参数表示后置",
		"类型转换构造函数声明：operator double()",
		"类型转换构造函数，在函数名前面不能指定函数类型,函数没有参数｡ 其返回值的类型是由函数名中指定的类型名来确定的｡ 类型转换函数只能作为成员函数,因为转换的主体是本类的对象｡ 不能作为友元函数或普通函数｡",
  ]
},

{
  title:"类的继承",
  body:[
		"派生类继承了基类的所有数据成员和成员函数",
		"class 派生类名：［继承方式］ 基类名{派生类新增加的成员};",
		"继承方式：public,private,protected, 继承方式是可选的，默认为private",
		"构造函数和析构函数是不能从基类继承的",
		"public继承，派生类保持基类原有的访问属性",
		"private私有继承，基类公用成员和保护成员在派生类中改为私有属性",
		"protected保护继承，基类公用成员和保护成员在派生类中改为保护成员",
		"通过基类的公用成员函数来引用基类的私有数据成员。"
  ]
},
{
  title:"类的多重继承",
  body:[
		"派生类构造函数名（总参数表列）：基类构造函数名（参数表列）{派生类中新增数据成员初始化语句}",
  ]
},
		
]


/*

派生类访问基类被覆盖成员方法：this->Parent::fn();

在构造对象时，先调用基类构造函数，再执行派生类构造函数
析构对象时，先执行派生类析构函数，再执行基类析构函数

派生类构造函数的任务：
1，基类数据成员的初始化
2，子对象数据成员的初始化
3，派生类数据成员的初始化

基类声明了带参数的构造函数，则派生类必须显示的调用基类的构造函数，并传入相应的初始化参数
基类的同名成员在派生类中屏蔽，需要通过this->Parent::name显示调用

虚基类构造函数，不仅要初始化基类构造函数，也需要初始化虚基类；

可以用子类(即公用派生类)对象对其基类对象赋值。

多态性定义：:向不同的对象发送同一个消息，不同的对象在接收时会产生不同的行为(即方法)。
多态性分为两类:静态多态性和动态多态性
静态多态性是通过函数的重载实现的
动态多态性是通过虚函数(virtual function)实现的。

{
  title:"",
  body:[
  ]
},
*/
